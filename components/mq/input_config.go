// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package mq

import (
	"encoding/json"
	"fmt"
)

type InputConfig struct {
	// Whether to automatically retry processing of failed messages.
	//
	AutoRetryNacks bool `json:"auto_retry_nacks,omitempty" yaml:"auto_retry_nacks,omitempty" mapstructure:"auto_retry_nacks,omitempty"`

	// The maximum number of messages to fetch at a time. Processing guarantees apply
	// to the batch, not individual messages. Higher values can improve throughput but
	// increase memory usage.
	//
	BatchCount int `json:"batch_count,omitempty" yaml:"batch_count,omitempty" mapstructure:"batch_count,omitempty"`

	// Number of parallel queue manager connections to use. Higher values can improve
	// throughput for high-volume queues.
	//
	NumThreads int `json:"num_threads,omitempty" yaml:"num_threads,omitempty" mapstructure:"num_threads,omitempty"`

	// The IBM MQ queue name to read messages from.
	//
	QueueName string `json:"queue_name" yaml:"queue_name" mapstructure:"queue_name"`

	// How long to wait before program exit after failure. This provides time for
	// graceful shutdown and cleanup. Specify as a duration string (e.g., "2m",
	// "30s").
	//
	SleepTimeBeforeExitAfterFailure string `json:"sleep_time_before_exit_after_failure,omitempty" yaml:"sleep_time_before_exit_after_failure,omitempty" mapstructure:"sleep_time_before_exit_after_failure,omitempty"`

	// How long to wait for messages when the queue is empty. Specify as a duration
	// string (e.g., "5s", "1m", "100ms").
	//
	WaitTime string `json:"wait_time,omitempty" yaml:"wait_time,omitempty" mapstructure:"wait_time,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InputConfig) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["queue_name"]; raw != nil && !ok {
		return fmt.Errorf("field queue_name in InputConfig: required")
	}
	type Plain InputConfig
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["auto_retry_nacks"]; !ok || v == nil {
		plain.AutoRetryNacks = true
	}
	if v, ok := raw["batch_count"]; !ok || v == nil {
		plain.BatchCount = 1.0
	}
	if 1 > plain.BatchCount {
		return fmt.Errorf("field %s: must be >= %v", "batch_count", 1)
	}
	if v, ok := raw["num_threads"]; !ok || v == nil {
		plain.NumThreads = 1.0
	}
	if 1 > plain.NumThreads {
		return fmt.Errorf("field %s: must be >= %v", "num_threads", 1)
	}
	if v, ok := raw["sleep_time_before_exit_after_failure"]; !ok || v == nil {
		plain.SleepTimeBeforeExitAfterFailure = "2m"
	}
	if v, ok := raw["wait_time"]; !ok || v == nil {
		plain.WaitTime = "5s"
	}
	*j = InputConfig(plain)
	return nil
}
