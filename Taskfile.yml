version: "3"

silent: true

vars:
  ALL_COMPONENTS: "aws-eventbridge aws-s3 ibm-mq mqtt nats"
  SIMPLE_COMPONENTS: "aws-eventbridge aws-s3 mqtt nats"

includes:
  bundles:
    taskfile: ./bundles/Taskfile.yml
    dir: ./bundles
  framework:
    taskfile: ./framework/Taskfile.yml 
    dir: ./framework

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list-all

  # Development Environment
  setup:
    desc: Setup development environment
    cmds:
      - go version
      - go mod tidy
      - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
      - go install golang.org/x/tools/cmd/goimports@latest
      - go install github.com/atombender/go-jsonschema@84c8d2b98bf0373873df8a353b122530a7110c70
      - go install github.com/goreleaser/goreleaser/v2@latest

  # Code Quality
  check:
    desc: Run all code quality checks (lint, format, vet)
    cmds:
      - task: lint
      - task: format:check
      - task: vet

  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run ./...

  lint:fix:
    desc: Run golangci-lint with auto-fix
    cmds:
      - golangci-lint run --fix ./...

  format:
    desc: Format all Go code
    cmds:
      - gofmt -w -s .
      - goimports -w .
      - task: framework:format
      - task: bundles:all:format

  format:check:
    desc: Check if code is formatted
    cmds:
      - test -z "$(gofmt -l .)" || (echo "Code is not formatted. Run 'task format' to fix." && exit 1)

  vet:
    desc: Run go vet on all modules
    cmds:
      - task: framework:vet
      - task: bundles:all:vet

  # Testing
  test:all:
    desc: Run all tests (unit + integration)
    cmds:
      - task: framework:test
      - task: bundles:all:test
        vars:
          COMPONENTS: '{{.ALL_COMPONENTS}}'

  test:
    desc: Run all tests (unit + integration)
    cmds:
      - task: framework:test
      - task: bundles:all:test
        vars:
          COMPONENTS: '{{.SIMPLE_COMPONENTS}}'

  test:unit:
    desc: Run unit tests only (fast, no external dependencies)
    cmds:
      - task: framework:test:unit
      - task: bundles:all:test:unit
        vars:
          COMPONENTS: '{{.SIMPLE_COMPONENTS}}'

  test:integration:
    desc: Run integration tests only (requires external services)
    cmds:
      - task: framework:test:integration
      - task: bundles:all:test:integration
        vars:
          COMPONENTS: '{{.SIMPLE_COMPONENTS}}'

  test:race:
    desc: Run all tests with race detector
    cmds:
      - task: framework:test:race
      - task: bundles:all:test:race
        vars:
          COMPONENTS: '{{.SIMPLE_COMPONENTS}}'

  test:coverage:
    desc: Run tests with coverage report
    cmds:
      - task: framework:test:coverage
      - task: bundles:all:test:coverage
        vars:
          COMPONENTS: '{{.SIMPLE_COMPONENTS}}'

  # Validation and Build
  validate:
    desc: Validate all modules
    cmds:
      - task: framework:validate
      - task: bundles:all:validate
        vars:
          COMPONENTS: '{{.ALL_COMPONENTS}}'
        
  build:
    desc: Build all workspace modules
    cmds:
      - task: framework:build
      - task: bundles:all:build
        vars:
          COMPONENTS: '{{.SIMPLE_COMPONENTS}}'

  build:check:
    desc: Check that all modules build successfully
    cmds:
      - task: build

  # Dependencies
  deps:tidy:
    desc: Tidy module dependencies
    cmds:
      - go mod tidy

  deps:update:
    desc: Update all dependencies
    cmds:
      - go get -u ./...
      - go mod tidy

  # Release Management
  release:snapshot:
    desc: Create a local snapshot release (no git operations)
    cmds:
      - goreleaser release --snapshot --clean --skip=publish

  release:rc:
    desc: Create a release candidate
    vars:
      CURRENT_TAG:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0"
      NEXT_RC:
        sh: |
          if [ -z "{{.VERSION}}" ]; then
            current_tag=$(git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0")
            if echo "$current_tag" | grep -q "\-rc"; then
              # Extract base version and RC number
              base=$(echo "$current_tag" | sed 's/-rc.*//')
              rc_num=$(echo "$current_tag" | sed 's/.*-rc//')
              next_rc=$((rc_num + 1))
              echo "${base}-rc${next_rc}" | sed 's/^v//'
            else
              # No RC suffix, this is a new RC series
              echo "${current_tag}-rc1" | sed 's/^v//'
            fi
          else
            echo "{{.VERSION}}"
          fi
      TAG_VERSION: "v{{.NEXT_RC}}"
    cmds:
      - task: release:check
      - task: check
      - task: test
      - |
        echo "Creating release candidate: {{.TAG_VERSION}}"
        
        # Validate version format
        if ! echo "{{.NEXT_RC}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-rc[0-9]+)?$'; then
          echo "Error: Invalid version format. Expected: X.Y.Z or X.Y.Z-rcN"
          exit 1
        fi
        
        # Check if tag already exists
        if git rev-parse "{{.TAG_VERSION}}" >/dev/null 2>&1; then
          echo "Error: Tag {{.TAG_VERSION}} already exists"
          exit 1
        fi
        
        # Create and push tag
        git tag -a "{{.TAG_VERSION}}" -m "Release candidate {{.TAG_VERSION}}"
        git push origin "{{.TAG_VERSION}}"
        
        echo "✅ Tag {{.TAG_VERSION}} created and pushed"
        echo "GitHub Actions will now create the release using goreleaser"

  release:final:
    desc: Create a final release
    vars:
      CURRENT_TAG:
        sh: git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0"
      FINAL_VERSION:
        sh: |
          if [ -z "{{.VERSION}}" ]; then
            current_tag=$(git describe --tags --always --abbrev=0 --match='v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || echo "v0.0.0")
            # Remove RC suffix if present
            echo "$current_tag" | sed 's/-rc.*//' | sed 's/^v//'
          else
            echo "{{.VERSION}}"
          fi
      TAG_VERSION: "v{{.FINAL_VERSION}}"
    cmds:
      - task: release:check
      - task: check
      - task: test
      - |
        echo "Creating final release: {{.TAG_VERSION}}"
        
        # Validate version format (no RC suffix allowed)
        if ! echo "{{.FINAL_VERSION}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
          echo "Error: Invalid version format. Expected: X.Y.Z (no RC suffix)"
          exit 1
        fi
        
        # Check if tag already exists
        if git rev-parse "{{.TAG_VERSION}}" >/dev/null 2>&1; then
          echo "Error: Tag {{.TAG_VERSION}} already exists"
          exit 1
        fi
        
        # Create and push tag
        git tag -a "{{.TAG_VERSION}}" -m "Release {{.TAG_VERSION}}"
        git push origin "{{.TAG_VERSION}}"
        
        echo "✅ Tag {{.TAG_VERSION}} created and pushed"
        echo "GitHub Actions will now create the release using goreleaser"

  release:check:
    desc: Pre-release checks
    cmds:
      - |
        # Check for uncommitted changes
        if [ -n "$(git status --porcelain)" ]; then
          echo "Error: Uncommitted changes detected. Please commit or stash changes before releasing."
          exit 1
        fi
      - |
        # Check we're on main branch
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$BRANCH" != "main" ]; then
          echo "Error: Releases must be created from main branch. Currently on: $BRANCH"
          exit 1
        fi
      - |
        # Ensure we have latest changes
        git fetch origin main
        if [ $(git rev-list HEAD...origin/main --count) -gt 0 ]; then
          echo "Error: Local main branch is not up to date with origin. Please pull latest changes."
          exit 1
        fi
      - echo "✅ Pre-release checks passed"

  release:validate:
    desc: Validate version format
    vars:
      VERSION: '{{.VERSION | default ""}}'
    cmds:
      - |
        if [ -z "{{.VERSION}}" ]; then
          echo "Error: VERSION not provided"
          echo "Usage: task release:validate VERSION=X.Y.Z[-rcN]"
          exit 1
        fi
        
        if echo "{{.VERSION}}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-rc[0-9]+)?$'; then
          echo "✅ Valid version format: {{.VERSION}}"
        else
          echo "❌ Invalid version format: {{.VERSION}}"
          echo "Expected format: X.Y.Z or X.Y.Z-rcN"
          exit 1
        fi

  release:list:
    desc: List recent releases
    cmds:
      - gh release list --limit 20

  release:current:
    desc: Show current version
    cmds:
      - |
        CURRENT=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "v0.0.0")
        echo "Current version: $CURRENT"
        
        # Check if there are commits since last tag
        if [ "$CURRENT" != "v0.0.0" ]; then
          COMMITS_SINCE=$(git rev-list --count $CURRENT..HEAD)
          if [ $COMMITS_SINCE -gt 0 ]; then
            echo "Commits since $CURRENT: $COMMITS_SINCE"
          fi
        fi